Git安装完成后，还需要最后一步设置，在命令行输入：

$ git config --global user.name "Your Name"
$ git config --global user.email "email@example.com"
git config命令的--global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。

要随时掌握工作区的状态，使用git status命令

初始化一个Git仓库:git init
添加文件到Git仓库，分两步：

    使用命令git add <file>，注意，可反复多次使用，添加多个文件；
    使用命令git commit -m <message>，完成。（-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。）
	例：
	$ git add file1.txt
	$ git add file2.txt file3.txt
	$ git commit -m "add 3 files."

git diff 命令用来查看同一个文件前后两次修改的区别
	例：$ git diff readme.txt

git diff    #是工作区(work dict)和暂存区(stage)的比较
git diff --cached    #是暂存区(stage)和分支(master)的比较
git diff HEAD  #查看工作区和版本库里面最新版本的区别（如：git diff HEAD -- readme.txt 可以查看工作区和版本库里面最新版本的区别）
    git diff比较的是工作目录中当前文件和暂存区域快照之间的差异， 也就是修改之后还没有暂存起来的变化内容。若要查看已暂存的将要添加到下次提交里的内容，可以用 git diff --cached 命令。
    请注意，git diff 本身只显示尚未暂存的改动，而不是自上次提交以来所做的所有改动。 所以有时候你一下子暂存了所有更新过的文件后，运行 git diff 后却什么也没有，就是这个原因。
	暂存区的文件目录和最近一次git add之后工作区的文件目录是一致的，因此当你修改完文件使用git diff你可以看到工作区和暂存区的差异（此时暂存区是上一次add之后的目录，而工作区是你刚修改完的样子），
	使用git add加入新的修改，再git diff就不会有输出，因为暂存区被更新为最新的工作区目录。 git diff --cached同理，只是比较的是暂存区和分支里的内容差异（分支保持上一次git commit的目录）。

	例：如下操作：
	第一次修改后 -> git add -> 第二次修改后 -> git commit
	Git管理的是修改，当用git add命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，git commit只负责把暂存区的修改提交了，
	也就是第一次的修改被提交了，第二次的修改不会被提交。

git log命令显示从最近到最远的提交日志。如果嫌输出信息太多，看得眼花缭乱的，可以试试加上--pretty=oneline或者--oneline参数。
说明：git log --oneline 和 git log --pretty=oneline 都能log，没有pretty的是只有commit id 前7位，加pretty的是全部的id。

git reflog命令可以查看命令历史。

用git reset命令进行版本回退。在Git中，用HEAD表示当前版本，上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。
总结：
    HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id。（例：$ git reset --hard 1094a）
    版本替换前，用git log可以查看提交历史，以便确定要回退到哪个版本。版本号没必要写全，前几位就可以了，Git会自动去找。
    要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。

删除文件:
一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用rm命令删了：
$ rm test.txt
现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit；
另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：

$ git checkout -- test.txt
git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。

小结：
命令git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。
	
================
本地及远程版本冲突的解决办法：

假设一开始你的本地和远程都是：
a -> b -> c
你想把HEAD回退到b，那么在本地就变成了：
a -> b
这个时候，如果没有远程库，你就接着怎么操作都行，比如：
a -> b -> d
但是在有远程库的情况下，你push会失败，因为远程库是 a->b->c，你的是 a->b->d
两种方案：
    push的时候用--force，强制把远程库变成a -> b -> d，大部分公司严禁这么干，会被别人揍一顿
    做一个反向操作，把自己本地变成a -> b -> c -> d，注意b和d文件快照内容一莫一样，但是commit id肯定不同，再push上去远程也会变成 a -> b -> c -> d
简单地说就是你无法容易地抹去远程库的提交信息，所以本地提交怎么都行，push前想好了
=================
